1.有两种方式来实现并发性，一种方式是让每个“任务”或“进程”在单独的内在空间中工作，每个都有自已的工作内存区域。不过，虽然进程可在单独的内存空间中执行，但除非这些进程在单独的处理器上执行，否则，实际并不是“同时”运行的。是由操作系统把处理器的时间片分配给一个进程，用完时间片后就需退出处理器等待另一个时间片的到来。另一种方式是在在程序中指定多个“执行线程”，让它们在相同的内存空间中工作。这称为“多线程处理”。线程比进程更有效，因为操作系统不必为每个线程创建单独的内存空间。

2. 新建进程用os.fork函数。但它只在POSIX系统上可用，在windows版的python中，os模块没有定义os.fork函数。相反，windows程序员用多线程编程技术来完成并发任务。

3. os.fork 函数创建进程的过程是这样的。程序每次执行时，操作系统都会创建一个新进程来运行程序指令。进程还可调用os.fork，要求操作系统新建一个进程。父进程是调用os.fork函数的进程。父进程所创建的进程叫子进程。每个进程都有一个不重复的进程ID号。或称pid，它对进程进行标识。子进程与父进程完全相同，子进程从父进程继承了多个值的拷贝，如全局变量和环境变量。两个进程的唯一区别是fork的返回值。子进程接收返回值0，而父进程接收子进程的 pid作为返回值。

4. 用os.fork创建的子进程和父进程作为异步的并发进程而单独执行。异步是指它们各行其是，相互间不进行同步；并发是指它们可同时执行。所以我们无法知道子进程和父进程的相对速度

5. os.wait 函数用于等待子进程结束(只适用于UNIX兼容系统)。该函数返回包含两个元素的元组，包括已完成的子进程号pid，以及子进程的退出状态，返回状态为 0，表明子进程成功完成。返回状态为正整数表明子进程终止时出错。如没有子进程，会引发OSError错误。os.wait要求父进程等待它的任何一个子进程结束执行，然后唤醒父进程。

6.要指示父进程等候一个指定的子进程终止，可在父进程中使用os.waitpid函数(只适用于unix兼容系统)。它可等候一个指定进程结束，然后返回一个双元素元组，其中包括子进程的pid和子进程的退出状态。函数调用将pid作为第一个参数传递，并将一个选项作为第二个选项，如果第一个参数大于0，则 waitpid会等待该pid结束，如果第一个参数是-1，则会等候所有子进程，也就和os.wait一样。

7. 用os.system 和 os.exec函数族来执行系统命令和其它程序。os.system使用shell来执行系统命令，然后在命令结束之后把控制权返回给原始进程；os.exec函数族在执行完命令后不将控制权返回给调用进程。它会接管python进程，pid不变。这两个函数支持unix和windows平台。

8. os.popen() 函数可执行命令，并获得命令的stdout流。函数要取得两个参数，一个是要执行的命令，另一个是调用函数所用的模式，如“r”只读模式。 os.popen2()函数执行命令，并获得命令的stdout流和stdin流。函数返回一个元组，其中包含有两个文件对象，一个对象对应stdin 流，一个对象对应stdout流。

9. 进程使用IPC机制在进程间传递信息，一种IPC机制是“管道”，它是一种类似于文件的对象，提供单向通信渠道。父进程可打开一个管道，再分支一个子进程。父进程使用管道将信息写入(发送到)子进程，而子进程使用管道从父进程读取信息。在python中使用os.pipe函数创建管道。

10.os._exit() 类似于sys.exit()，但它不执行任何的清除工作(例如刷新缓冲区)。所以os._exit()尤其适用于退出子进程。如果程序使用 sys.exit()，操作系统会回收父进程或其它子进程可能仍然需要的资源。传给os._exit()函数的参数必须是进程的退出状态。退出状态为0，表示正常终止。

11. 进程也可用信号进行通信。所谓“信号”，是操作系统采取异步方式传给程序的消息。如CTRL+C会传递一个“中断信号”，通常该信号导致程序中止。然而程序完全可以指定用不同的行动来响应任何一个信号。在信号处理中，程序要接收信号，并根据那个信号采取一项行动。错误(例如向已关闭管道写入)、事件(例如计时器变成0)以及用户输入(例如按ctrl+c)都会产生信号。

12. 针对每个信号，每个python程序都有一个默认的信号处理程序。例如，假定python解释器收到一个信号，该信号指出程序试图向已关闭的管道写入，或者用户敲入一个键盘中断，python就会引发一个异常。发生异常后，程序既可使用默认处理程序，也可使用自定义处理程序。

13. signal.signal函数为中断信号注册一个信号处理程序。函数要获得两个参数：一个信号和一个对应于信号处理程序的函数。

14. 在 unix/linux系统中，子进程终止后，会保留在进程表中，让父进程知道子进程是否正常终止。如果创建大量子进程，但在终止后没有从进程表中移除它们，进程表便会积累越来越多的死进程，这些进程称为“zombies”(僵尸进程)，消除僵尸进程的操作称为“reaping”，这是通过os.wait 和os.waitpid函数实现的。



18.2. 良好的编程习惯

1. 进程应关闭不需要的管道端，因为操作系统限制了可同时打开的文件说明符数量。

 


18.3. 移植性提示

1.并不是所有操作系统都能从一个正在运行的程序创建单独的进程，所以，进程管理是移植性最差的一项python特性。

2. 每个系统都定义了特有信号集。signal是依赖于具体平台的模块，其中只包含系统定义的信号。



参考自：http://blog.163.com/longsu2010@yeah/blog/static/1736123482011292132926/